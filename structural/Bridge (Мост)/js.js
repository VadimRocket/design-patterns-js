/*
11 - Bridge (Мост) - Порождающий паттерн который разделяет 1 или несколько классов на 
    несколько отдельных иерархий, которые наз-ся абстракцией и реализация. это помогает изменять их
    без зависимостей др. от друга.

    Рассмотрим на теоретич. примере. Пусть у нас есть 2 авто БМВ и АУДИ - 2 подкласса корневого класса АВТО.
    Предположим мы хотим расширить эту структуру цветами: Черный и серебристый. Т.о 2 наших подкласса превращ-ся в 4.
    : Черный и серебристый БМВ и Черный и серебристый АУДИ. 
    Каждый раз при добавлении нового типа авто или его цвета, кол-во подклассов будет расти в геометрич-й прогрессии.

    Паттерн мост помогает решить проблему заменив наследование на композицию
    Для этого предлаг-ся выделить 1 из направлений в 1 из иерархий. И после этого ссылаться на объект иерархии в место 
    того чтобы хранить его состояние и поведение внутри корневого класса.

    Т.о мы можем сделать модели авто отдельным классом с подклассами черный и серебристый, а класс цветов получит ссылку на класс 
    моделей и в случае необходимости может делегировать ему работу. ТАКАЯ СВЯЗЬ наз-ся Мостом между моделями и цветом.

    При добавлении новых цветов не пол-ся изменять модели, а при добавлении моделей - Цвета.

    Практика:   
    ---------

    1. Отказаться от корневого класса, в который будут входить под корневые классы.
    2. Разделить все на абстракцию (специальная обертка которая не выполняет работу, а делегирует 1 из объектов реализации.)
       и реализацию (реализация - объект в котором описана сама реализация).
*/
// описание модели
class Model {
    constructor(color) {
        this.color = color;
    }
}

// описание цвета
class Color {
    constructor(type) {
        this.type = type;
    }
    get() {
        return this.type;
    }
}

// подклассы  BlackColor RedColor работают с цветами не имея инфы о модели 
class BlackColor extends Color {
    constructor() {
        super("dark-color");
    }
}

class RedColor extends Color {
    constructor() {
        super("red-color");
    }
}

/*
    Создадим 2 модели Ауди и БМВ.
    В конструкторе этих моделей задается цвет.
    Сами модели с цветами не работают единств-е что у них есть - метод paint покраски авто
    в котором делегируется работа в класс Color в котором опис-ся метод гет.
 */
class Audi extends Model {
    constructor(color) {
        super(color);
    }

    paint() {
        return  `Auto: Audi, Color ${ this.color.get() }`;
    }
}

class Bmw extends Model {
    constructor(color) {
        super(color);
    }

    paint() {
        return  `Auto: Bmw, Color ${ this.color.get() }`;
    }
}
 
/*
на данный момент есть 2 класса которые могут меняться независимо друг от друга
Каждый знает класс только о своих изменениях. Но связь или мост между ними есть.
Эта связь описана в методе paint()  {return  `Auto: Audi, Color ${ this.color.get() }`;}
Мостом  в данной имплементации явл-ся класс Color c методом get 'дергающий' классы цветов

Есть возможность ввести еще 1 уровень дополнит-й абстракции:  С описанием вызова метода paint() и брать его Чтобы не указывать в модели
Но в нашем примере Это можно не делать т.к Это будет избыточно.. Но ПОМНИ О ЭТОЙ ВОЗМОЖНОСТИ
*/

// Create car using model and color
// Вызываем создание определенной модели Авто внутрь которого передаем конструктор цвета. Т.о мы разделили 2 направления создания и изолировали их др. от др.
const blackBmw = new Bmw(new BlackColor()); 


console.log(blackBmw.paint());  // --> Auto: Bmw, Color dark-color

// Обычно вводят данный паттерн, когда корневой класс разрастается и его надо разделить.